<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Transaction Management & Recovery</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 900px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .slide {
            display: none;
            padding: 50px;
            min-height: 600px;
            animation: fadeIn 0.5s;
        }

        .slide.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            color: #667eea;
            font-size: 2.3em;
            margin-bottom: 25px;
            border-bottom: 4px solid #667eea;
            padding-bottom: 15px;
        }

        h2 {
            color: #764ba2;
            font-size: 1.6em;
            margin: 20px 0 12px 0;
        }

        h3 {
            color: #555;
            font-size: 1.2em;
            margin: 15px 0 8px 0;
        }

        p, li {
            color: #333;
            line-height: 1.7;
            margin: 8px 0;
            font-size: 1.05em;
        }

        ul, ol {
            margin-left: 30px;
            margin-top: 12px;
        }

        li {
            margin: 6px 0;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #d63384;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 18px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            line-height: 1.5;
            font-size: 0.92em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 18px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 0.95em;
        }

        th, td {
            padding: 10px;
            text-align: left;
            border: 1px solid #ddd;
        }

        th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 50px;
            background: #f8f9fa;
            border-top: 2px solid #e9ecef;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 28px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s;
        }

        button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .slide-counter {
            font-size: 1.05em;
            color: #555;
            font-weight: bold;
        }

        .highlight {
            background: #fff3cd;
            padding: 12px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
            border-radius: 4px;
            font-size: 0.98em;
        }

        .success {
            background: #d4edda;
            border-left-color: #28a745;
        }

        .error {
            background: #f8d7da;
            border-left-color: #dc3545;
        }

        .info {
            background: #d1ecf1;
            border-left-color: #17a2b8;
        }

        .emoji {
            font-size: 1.2em;
            margin-right: 6px;
        }

        .example-box {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
            font-size: 0.95em;
        }

        .visual-schedule {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .timeline {
            margin: 15px 0;
            padding-left: 15px;
        }

        .timeline-item {
            padding: 8px;
            margin: 6px 0;
            border-left: 3px solid #667eea;
            padding-left: 12px;
            font-size: 0.95em;
        }

        .analogy-box {
            background: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
            border-radius: 5px;
        }

        .analogy-box::before {
            content: "üéØ Real-World Analogy: ";
            font-weight: bold;
            color: #856404;
        }

        .step-list {
            counter-reset: step;
            list-style: none;
            padding-left: 0;
        }

        .step-list li {
            counter-increment: step;
            padding: 10px;
            margin: 8px 0;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #667eea;
            position: relative;
            padding-left: 50px;
        }

        .step-list li::before {
            content: counter(step);
            position: absolute;
            left: 12px;
            top: 10px;
            background: #667eea;
            color: white;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Slide 1 -->
        <div class="slide active">
            <h1>Advanced Database Systems</h1>
            <h2>Transaction Management & Recovery</h2>
            <ul>
                <li>Transaction Management & ACID</li>
                <li>Schedules & Serializability</li>
                <li>Concurrency Control Mechanisms</li>
                <li>Database Recovery</li>
                <li>Log-Based Recovery & Checkpoints</li>
            </ul>
        </div>

        <!-- Slide 2 -->
        <div class="slide">
            <h1>What is a Transaction?</h1>
            <h3>Definition</h3>
            <p>A transaction is a logical unit of work that contains one or more SQL statements.</p>
            <h3>Key Concept</h3>
            <p>All operations must complete successfully, or none should take effect.</p>
            <div class="analogy-box">
                Like transferring money: Either both deduct AND deposit happen, or neither happens. No middle ground!
            </div>
            <h3>Example: Bank Transfer</h3>
            <pre>BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
COMMIT;</pre>
        </div>

        <!-- Slide 3 -->
        <div class="slide">
            <h1>Transaction States</h1>
            <h3>Five States of a Transaction:</h3>
            <ul>
                <li><strong>Active</strong> - Initial state, transaction is executing</li>
                <li><strong>Partially Committed</strong> - After final statement executes</li>
                <li><strong>Committed</strong> - After successful completion</li>
                <li><strong>Failed</strong> - After discovery that normal execution can't proceed</li>
                <li><strong>Aborted</strong> - After rollback and database restoration</li>
            </ul>
            <div class="highlight info">
                <span class="emoji">üí°</span>Transitions: Active ‚Üí Partially Committed ‚Üí Committed OR Active ‚Üí Failed ‚Üí Aborted
            </div>
        </div>

        <!-- Slide 4 -->
        <div class="slide">
            <h1>Database Setup</h1>
            <h3>Creating Tables for Examples</h3>
            <pre>CREATE TABLE accounts (
    account_id INTEGER PRIMARY KEY,
    account_holder TEXT NOT NULL,
    balance DECIMAL(10,2) NOT NULL,
    account_type TEXT
);

CREATE TABLE transactions_log (
    txn_id INTEGER PRIMARY KEY AUTOINCREMENT,
    account_id INTEGER,
    txn_type TEXT,
    amount DECIMAL(10,2),
    txn_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
);</pre>
        </div>

        <!-- Slide 5 -->
        <div class="slide">
            <h1>Sample Data</h1>
            <h3>Populating the Database</h3>
            <pre>INSERT INTO accounts VALUES 
    (1, 'Alice Johnson', 5000.00, 'Checking'),
    (2, 'Bob Smith', 3000.00, 'Savings'),
    (3, 'Charlie Brown', 7500.00, 'Checking'),
    (4, 'Diana Prince', 2000.00, 'Savings');</pre>
            <h3>Current State</h3>
            <table>
                <tr><th>ID</th><th>Holder</th><th>Balance</th><th>Type</th></tr>
                <tr><td>1</td><td>Alice</td><td>$5,000</td><td>Checking</td></tr>
                <tr><td>2</td><td>Bob</td><td>$3,000</td><td>Savings</td></tr>
                <tr><td>3</td><td>Charlie</td><td>$7,500</td><td>Checking</td></tr>
                <tr><td>4</td><td>Diana</td><td>$2,000</td><td>Savings</td></tr>
            </table>
        </div>

        <!-- Slide 6 -->
        <div class="slide">
            <h1>ACID Properties</h1>
            <h3>ACID ensures reliable transaction processing:</h3>
            <ul>
                <li><strong>A</strong>tomicity - All or Nothing</li>
                <li><strong>C</strong>onsistency - Valid State to Valid State</li>
                <li><strong>I</strong>solation - Transactions Don't Interfere</li>
                <li><strong>D</strong>urability - Changes Persist Forever</li>
            </ul>
            <p style="margin-top: 25px;">These properties guarantee database reliability even in the face of errors, power failures, and other mishaps.</p>
        </div>

        <!-- Slide 7 -->
        <div class="slide">
            <h1>Atomicity</h1>
            <h2>"All or Nothing"</h2>
            <h3>Definition</h3>
            <p>A transaction must be treated as a single, indivisible unit.</p>
            <div class="analogy-box">
                Like a chemical reaction - either all reactants form products, or nothing changes. No half-reactions!
            </div>
            <h3>Either:</h3>
            <ul>
                <li>All operations complete successfully (COMMIT)</li>
                <li>All operations are undone (ROLLBACK)</li>
            </ul>
            <p><strong>No partial execution is allowed.</strong></p>
        </div>

        <!-- Slide 8 -->
        <div class="slide">
            <h1>Atomicity - Success Case</h1>
            <h3>Transfer $500 from Alice to Bob</h3>
            <pre>BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 500 
WHERE account_id = 1;  -- Alice: $5000 ‚Üí $4500

UPDATE accounts SET balance = balance + 500 
WHERE account_id = 2;  -- Bob: $3000 ‚Üí $3500

COMMIT;</pre>
            <h3>Result:</h3>
            <table>
                <tr><th>Account</th><th>Before</th><th>After</th></tr>
                <tr><td>Alice</td><td>$5,000</td><td>$4,500</td></tr>
                <tr><td>Bob</td><td>$3,000</td><td>$3,500</td></tr>
            </table>
            <div class="highlight success">
                <span class="emoji">‚úÖ</span>Both updates complete - transaction commits successfully
            </div>
        </div>

        <!-- Slide 9 -->
        <div class="slide">
            <h1>Atomicity - Failure Case</h1>
            <h3>Failed Transfer Scenario</h3>
            <pre>BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 500 
WHERE account_id = 1;  -- Alice: $5000 ‚Üí $4500

-- System crash / Network error / Constraint violation
-- Before second update completes

ROLLBACK;  -- All changes undone</pre>
            <h3>Result:</h3>
            <table>
                <tr><th>Account</th><th>Attempted</th><th>Final State</th></tr>
                <tr><td>Alice</td><td>$4,500 (temp)</td><td>$5,000 (restored)</td></tr>
                <tr><td>Bob</td><td>No change</td><td>$3,000 (unchanged)</td></tr>
            </table>
            <div class="highlight error">
                <span class="emoji">‚ùå</span>Transaction rolled back - database restored to original state
            </div>
        </div>

        <!-- Slide 10 -->
        <div class="slide">
            <h1>Consistency</h1>
            <h2>Maintaining Database Rules</h2>
            <h3>Definition</h3>
            <p>A transaction must take the database from one valid state to another valid state.</p>
            <div class="analogy-box">
                Like accounting - books must always balance. Total money before = Total money after.
            </div>
            <h3>Ensures:</h3>
            <ul>
                <li>All integrity constraints are satisfied</li>
                <li>Business rules are maintained</li>
                <li>Database remains in a correct state</li>
            </ul>
        </div>

        <!-- Slide 11 -->
        <div class="slide">
            <h1>Consistency Example</h1>
            <h3>Conservation of Money</h3>
            <pre>-- Before transaction
SELECT SUM(balance) FROM accounts;  
-- Returns: $17,500

BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 1000 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 1000 WHERE account_id = 2;
COMMIT;

-- After transaction
SELECT SUM(balance) FROM accounts;  
-- Still Returns: $17,500 ‚úì</pre>
            <div class="highlight success">
                <span class="emoji">‚öñÔ∏è</span>Money is neither created nor destroyed - consistency maintained!
            </div>
        </div>

        <!-- Slide 12 -->
        <div class="slide">
            <h1>Isolation</h1>
            <h2>Concurrent Execution</h2>
            <h3>Definition</h3>
            <p>Multiple transactions executing concurrently should not interfere with each other.</p>
            <div class="analogy-box">
                Like multiple people editing a document - they shouldn't see each other's unfinished work or accidentally overwrite changes.
            </div>
            <h3>The Challenge</h3>
            <p>Balance between isolation (correctness) and performance (speed)</p>
        </div>

        <!-- Slide 13 -->
        <div class="slide">
            <h1>Lost Update Problem</h1>
            <h3>When Isolation Fails</h3>
            <div class="timeline">
                <div class="timeline-item"><strong>T1:</strong> Read balance = $5,000 (Alice's withdrawal)</div>
                <div class="timeline-item"><strong>T2:</strong> Read balance = $5,000 (Bob's deposit)</div>
                <div class="timeline-item"><strong>T1:</strong> Write balance = $4,500 (deduct $500)</div>
                <div class="timeline-item"><strong>T2:</strong> Write balance = $5,300 (add $300)</div>
            </div>
            <div class="highlight error">
                <span class="emoji">‚ö†Ô∏è</span><strong>Problem:</strong> T1's withdrawal lost! Should be $4,800, but it's $5,300
            </div>
        </div>

        <!-- Slide 14 -->
        <div class="slide">
            <h1>Isolation Levels</h1>
            <table>
                <tr>
                    <th>Level</th>
                    <th>Dirty Read</th>
                    <th>Non-Repeatable</th>
                    <th>Phantom</th>
                </tr>
                <tr>
                    <td>READ UNCOMMITTED</td>
                    <td>‚ùå Allowed</td>
                    <td>‚ùå Allowed</td>
                    <td>‚ùå Allowed</td>
                </tr>
                <tr>
                    <td>READ COMMITTED</td>
                    <td>‚úÖ Prevented</td>
                    <td>‚ùå Allowed</td>
                    <td>‚ùå Allowed</td>
                </tr>
                <tr>
                    <td>REPEATABLE READ</td>
                    <td>‚úÖ Prevented</td>
                    <td>‚úÖ Prevented</td>
                    <td>‚ùå Allowed</td>
                </tr>
                <tr>
                    <td>SERIALIZABLE</td>
                    <td>‚úÖ Prevented</td>
                    <td>‚úÖ Prevented</td>
                    <td>‚úÖ Prevented</td>
                </tr>
            </table>
            <div class="highlight">
                <span class="emoji">üîí</span><strong>Trade-off:</strong> Higher isolation = More consistency, Lower performance
            </div>
        </div>

        <!-- Slide 15 -->
        <div class="slide">
            <h1>Durability</h1>
            <h2>Permanent Changes</h2>
            <h3>Definition</h3>
            <p>Once a transaction commits, its changes must persist even in case of system failures.</p>
            <div class="analogy-box">
                Like saving a document - once you click "Save", it should survive even if power goes out!
            </div>
            <h3>Guarantees:</h3>
            <ul>
                <li>Committed transactions survive crashes</li>
                <li>Changes written to non-volatile storage</li>
                <li>Recovery mechanisms restore data</li>
            </ul>
        </div>

        <!-- NEW ENHANCED SCHEDULES SECTION -->
        
        <!-- Slide 16 -->
        <div class="slide">
            <h1>Understanding Schedules</h1>
            <h3>What is a Schedule?</h3>
            <p>A <strong>schedule</strong> is the <strong>order</strong> in which operations from multiple transactions are executed.</p>
            <div class="analogy-box">
                Restaurant kitchen with multiple chefs (transactions). A schedule is the order they use the stove, oven, counter (resources).
            </div>
            <h3>Three Types:</h3>
            <ul>
                <li><strong>Serial</strong> - One transaction at a time</li>
                <li><strong>Concurrent</strong> - Operations interleaved</li>
                <li><strong>Serializable</strong> - Concurrent but produces serial result</li>
            </ul>
        </div>

        <!-- Slide 17 -->
        <div class="slide">
            <h1>Serial Schedules</h1>
            <h3>Complete One, Then Next</h3>
            <div class="visual-schedule">
<strong>Serial Schedule: T1 then T2</strong>

T1: SELECT balance FROM accounts WHERE account_id = 1; -- $5000
T1: UPDATE accounts SET balance = 4500 WHERE account_id = 1;
T1: COMMIT;

T2: SELECT balance FROM accounts WHERE account_id = 1; -- $4500
T2: UPDATE accounts SET balance = 4725 WHERE account_id = 1; -- +5%
T2: COMMIT;

<strong>Final Result: $4725 ‚úì Correct!</strong>
            </div>
            <div class="highlight success">
                <span class="emoji">‚úÖ</span>Always correct, but slow (no concurrency)
            </div>
        </div>

        <!-- Slide 18 -->
        <div class="slide">
            <h1>Concurrent Schedules</h1>
            <h3>Operations Interleaved</h3>
            <div class="visual-schedule">
<strong>Concurrent Schedule (Problematic):</strong>

Time 1: T1 - SELECT balance FROM accounts... -- Reads $5000
Time 2: T2 - SELECT balance FROM accounts... -- Reads $5000 (same!)
Time 3: T1 - UPDATE accounts SET balance = 4500... (deduct $500)
Time 4: T2 - UPDATE accounts SET balance = 5250... (+5% of $5000)
Time 5: T1 - COMMIT;
Time 6: T2 - COMMIT;

<strong>Final Result: $5250 ‚úó Wrong! Should be $4725</strong>
<strong>T1's deduction was lost!</strong>
            </div>
            <div class="highlight error">
                <span class="emoji">‚ùå</span>Lost Update Problem - need concurrency control!
            </div>
        </div>

        <!-- Slide 19 -->
        <div class="slide">
            <h1>Serializable Schedules</h1>
            <h3>Goal: Best of Both Worlds</h3>
            <p>A concurrent schedule that produces the <strong>same result</strong> as some serial schedule.</p>
            <div class="example-box">
                <strong>Analogy:</strong> Multiple chefs working simultaneously (concurrent) but the dish tastes identical to one chef doing everything in order (serial).
            </div>
            <div class="highlight info">
                <span class="emoji">üéØ</span><strong>Goal:</strong> Speed of concurrent + Correctness of serial
            </div>
            <p><strong>Question:</strong> How do we test if a schedule is serializable?<br>
            <strong>Answer:</strong> Conflict Serializability Test!</p>
        </div>

        <!-- Slide 20 -->
        <div class="slide">
            <h1>Conflict Serializability</h1>
            <h3>What is a Conflict?</h3>
            <p>Two operations <strong>conflict</strong> if:</p>
            <ol class="step-list">
                <li>They belong to <strong>different</strong> transactions</li>
                <li>They access the <strong>same</strong> data item</li>
                <li>At least one is a <strong>WRITE</strong> operation</li>
            </ol>
            <div class="example-box">
                <strong>Examples:</strong><br>
                T1 reads Alice, T2 writes Alice ‚Üí <strong>Conflict!</strong> ‚ö†Ô∏è<br>
                T1 writes Bob, T2 reads Bob ‚Üí <strong>Conflict!</strong> ‚ö†Ô∏è<br>
                T1 reads Alice, T2 reads Alice ‚Üí <strong>No conflict</strong> ‚úì
            </div>
        </div>

        <!-- Slide 21 -->
        <div class="slide">
            <h1>Types of Conflicts</h1>
            <table>
                <tr>
                    <th>Conflict Type</th>
                    <th>T1 Operation</th>
                    <th>T2 Operation</th>
                    <th>Problem</th>
                </tr>
                <tr>
                    <td><strong>Read-Write (RW)</strong></td>
                    <td>Read(Alice)</td>
                    <td>Write(Alice)</td>
                    <td>T1 might read old value</td>
                </tr>
                <tr>
                    <td><strong>Write-Read (WR)</strong></td>
                    <td>Write(Alice)</td>
                    <td>Read(Alice)</td>
                    <td>Dirty read possible</td>
                </tr>
                <tr>
                    <td><strong>Write-Write (WW)</strong></td>
                    <td>Write(Alice)</td>
                    <td>Write(Alice)</td>
                    <td>Lost update possible</td>
                </tr>
            </table>
        </div>

        <!-- Slide 22 -->
        <div class="slide">
            <h1>Precedence Graph Method</h1>
            <h3>Testing Serializability</h3>
            <ol class="step-list">
                <li>Draw a <strong>node</strong> for each transaction</li>
                <li>Draw an <strong>arrow T1 ‚Üí T2</strong> if T1's operation conflicts with and comes before T2's operation</li>
                <li>Check for <strong>cycles</strong> in the graph</li>
                <li><strong>No cycle</strong> = Conflict Serializable ‚úì<br><strong>Cycle exists</strong> = NOT Serializable ‚úó</li>
            </ol>
        </div>

        <!-- Slide 23 -->
        <div class="slide">
            <h1>Precedence Graph Example</h1>
            <h3>Serializable Schedule</h3>
            <pre>-- T1: Update Alice
BEGIN; SELECT balance FROM accounts WHERE account_id = 1;
UPDATE accounts SET balance = 4500 WHERE account_id = 1; COMMIT;

-- T2: Read Alice, Update Bob  
BEGIN; SELECT balance FROM accounts WHERE account_id = 1;
UPDATE accounts SET balance = 3500 WHERE account_id = 2; COMMIT;

-- T3: Read Bob, Update Charlie
BEGIN; SELECT balance FROM accounts WHERE account_id = 2;
UPDATE accounts SET balance = 8000 WHERE account_id = 3; COMMIT;</pre>
            <div class="visual-schedule">
<strong>Conflicts:</strong>
T1 writes Alice, T2 reads Alice ‚Üí T1 ‚Üí T2
T2 writes Bob, T3 reads Bob ‚Üí T2 ‚Üí T3

<strong>Graph:</strong> T1 ‚Üí T2 ‚Üí T3

<strong>No cycle! ‚úì This schedule IS conflict serializable</strong>
Equivalent to serial order: T1, T2, T3
            </div>
        </div>

        <!-- Slide 24 -->
        <div class="slide">
            <h1>Non-Serializable Example</h1>
            <h3>Schedule with Cycle</h3>
            <pre>-- T1: Read Alice, Write Bob
BEGIN; 
SELECT * FROM accounts WHERE account_id = 1; -- Read Alice
UPDATE accounts SET balance = 3500 WHERE account_id = 2; -- Write Bob
COMMIT;

-- T2: Read Bob, Write Alice
BEGIN;
SELECT * FROM accounts WHERE account_id = 2; -- Read Bob
UPDATE accounts SET balance = 4500 WHERE account_id = 1; -- Write Alice
COMMIT;</pre>
            <div class="visual-schedule">
<strong>Conflicts:</strong>
T1 writes Bob, T2 reads Bob ‚Üí T1 ‚Üí T2
T2 writes Alice, T1 reads Alice ‚Üí T2 ‚Üí T1

<strong>Graph:</strong> T1 ‚áÑ T2  (Cycle!)

<strong>‚ùå NOT conflict serializable - cannot be reordered to serial</strong>
            </div>
        </div>

        <!-- Slide 25 -->
        <div class="slide">
            <h1>View Serializability</h1>
            <h3>Less Restrictive Approach</h3>
            <p>Two schedules are <strong>view equivalent</strong> if:</p>
            <ol class="step-list">
                <li><strong>Same initial reads:</strong> Transactions read same initial values</li>
                <li><strong>Same read-from:</strong> If T2 reads value written by T1, this is preserved</li>
                <li><strong>Same final writes:</strong> Final database state is identical</li>
            </ol>
            <div class="highlight info">
                <span class="emoji">üí°</span><strong>Relationship:</strong> View Serializable ‚äá Conflict Serializable<br>(View is broader - includes more schedules)
            </div>
        </div>

        <!-- CONCURRENCY CONTROL SECTION -->

        <!-- Slide 26 -->
        <div class="slide">
            <h1>Concurrency Control</h1>
            <h3>Why Do We Need It?</h3>
            <p>To ensure concurrent transactions don't interfere while maximizing performance.</p>
            <div class="analogy-box">
                Library with one copy of a popular book. Concurrency control is the checkout system preventing two people from taking the same book while allowing many to browse different books.
            </div>
            <h3>Benefits:</h3>
            <ul>
                <li>Higher throughput (more transactions/second)</li>
                <li>Better response time</li>
                <li>Efficient resource use</li>
            </ul>
        </div>

        <!-- Slide 27 -->
        <div class="slide">
            <h1>Lock-Based Protocols</h1>
            <h3>Controlling Access to Data</h3>
            <p>Use <strong>locks</strong> to control who can read/write data items.</p>
            <table>
                <tr>
                    <th>Lock Type</th>
                    <th>Purpose</th>
                    <th>Who Can Hold It?</th>
                </tr>
                <tr>
                    <td><strong>Shared Lock (S)</strong></td>
                    <td>For reading data</td>
                    <td>Multiple transactions</td>
                </tr>
                <tr>
                    <td><strong>Exclusive Lock (X)</strong></td>
                    <td>For writing/updating</td>
                    <td>Only ONE transaction</td>
                </tr>
            </table>
            <div class="analogy-box">
                Shared = Many people can read a book simultaneously<br>
                Exclusive = Only one person can edit the book at a time
            </div>
        </div>

        <!-- Slide 28 -->
        <div class="slide">
            <h1>Lock Compatibility</h1>
            <table>
                <tr>
                    <th>Current Lock</th>
                    <th>Request Shared</th>
                    <th>Request Exclusive</th>
                </tr>
                <tr>
                    <td>None</td>
                    <td>‚úÖ Grant</td>
                    <td>‚úÖ Grant</td>
                </tr>
                <tr>
                    <td>Shared</td>
                    <td>‚úÖ Grant (Multiple readers OK)</td>
                    <td>‚ùå Wait</td>
                </tr>
                <tr>
                    <td>Exclusive</td>
                    <td>‚ùå Wait</td>
                    <td>‚ùå Wait</td>
                </tr>
            </table>
            <div class="example-box">
                <strong>Scenario:</strong> Alice's account balance<br>
                ‚Ä¢ T1 reads balance ‚Üí Gets Shared Lock ‚úì<br>
                ‚Ä¢ T2 reads balance ‚Üí Gets Shared Lock ‚úì<br>
                ‚Ä¢ T3 wants to update ‚Üí Waits for both to finish ‚è≥
            </div>
        </div>

        <!-- Slide 29 -->
        <div class="slide">
            <h1>Locking in Practice</h1>
            <h3>SQLite Handles This Automatically</h3>
            <pre>-- What you write:
BEGIN TRANSACTION;
SELECT balance FROM accounts WHERE account_id = 1;
UPDATE accounts SET balance = 4500 WHERE account_id = 1;
COMMIT;

-- What SQLite does internally:
-- 1. Acquire Shared Lock on account 1 (for SELECT)
-- 2. Upgrade to Exclusive Lock on account 1 (for UPDATE)
-- 3. Hold lock until COMMIT
-- 4. Release all locks</pre>
            <div class="highlight info">
                <span class="emoji">üîí</span>You don't write lock commands - database handles it!
            </div>
        </div>

        <!-- Slide 30 -->
        <div class="slide">
            <h1>Two-Phase Locking (2PL)</h1>
            <h3>The Golden Rule for Serializability</h3>
            <p>Every transaction must follow two phases:</p>
            <div class="visual-schedule">
<strong>Phase 1: GROWING PHASE</strong>
üìà Can ACQUIRE locks (Shared or Exclusive)
‚ùå Cannot RELEASE any locks

--- LOCK POINT (Maximum locks held) ---

<strong>Phase 2: SHRINKING PHASE</strong>
üìâ Can RELEASE locks
‚ùå Cannot ACQUIRE new locks
            </div>
            <div class="highlight success">
                <span class="emoji">‚úÖ</span><strong>Guarantee:</strong> 2PL ensures conflict serializability!
            </div>
        </div>

        <!-- Slide 31 -->
        <div class="slide">
            <h1>2PL Example</h1>
            <h3>Visualizing the Phases</h3>
            <div class="visual-schedule">
<strong>Transaction T1:</strong>

BEGIN TRANSACTION;

-- GROWING PHASE: Acquire locks
Lock Alice's row (for SELECT)          ‚Üë
Lock Bob's row (for UPDATE)            ‚Üë Acquiring
Lock Charlie's row (for SELECT)        ‚Üë

-- Perform all operations
SELECT * FROM accounts WHERE account_id = 1;
UPDATE accounts SET balance = 3500 WHERE account_id = 2;
SELECT * FROM accounts WHERE account_id = 3;

--- LOCK POINT (all locks held) ---

COMMIT;

-- SHRINKING PHASE: Release all locks
Unlock Alice                           ‚Üì
Unlock Bob                             ‚Üì Releasing
Unlock Charlie                         ‚Üì
            </div>
        </div>

        <!-- Slide 32 -->
        <div class="slide">
            <h1>Strict Two-Phase Locking</h1>
            <h3>Enhanced Version (Most Common)</h3>
            <p><strong>Rule:</strong> Hold <strong>ALL</strong> locks until transaction commits or aborts</p>
            <pre>BEGIN TRANSACTION;

-- Acquire locks as needed
SELECT * FROM accounts WHERE account_id = 1; -- Lock Alice
UPDATE accounts SET balance = 4500 WHERE account_id = 1;

SELECT * FROM accounts WHERE account_id = 2; -- Lock Bob  
UPDATE accounts SET balance = 3500 WHERE account_id = 2;

-- Hold ALL locks until commit
COMMIT; -- Now release everything at once</pre>
            <h3>Benefits:</h3>
            <ul>
                <li>‚úÖ Prevents cascading rollbacks</li>
                <li>‚úÖ Ensures recoverability</li>
                <li>‚úÖ Most practical for real systems</li>
            </ul>
        </div>

        <!-- Slide 33 -->
        <div class="slide">
            <h1>The Deadlock Problem</h1>
            <h3>Circular Wait Situation</h3>
            <div class="visual-schedule">
<strong>Time  Transaction 1              Transaction 2</strong>
1     BEGIN;
      UPDATE accounts 
      SET balance = 4500
      WHERE account_id = 1;
      -- T1 locks Alice ‚úì
      
2                                 BEGIN;
                                  UPDATE accounts 
                                  SET balance = 3500
                                  WHERE account_id = 2;
                                  -- T2 locks Bob ‚úì
                                  
3     UPDATE accounts
      SET balance = 2500
      WHERE account_id = 2;
      -- T1 waits for Bob ‚è≥
      
4                                 UPDATE accounts
                                  SET balance = 5500
                                  WHERE account_id = 1;
                                  -- T2 waits for Alice ‚è≥

<strong>üîÑ DEADLOCK! Both wait forever for each other</strong>
            </div>
        </div>

        <!-- Slide 34 -->
        <div class="slide">
            <h1>Deadlock Prevention</h1>
            <h3>Strategy 1: Wait-Die</h3>
            <p><strong>Rule:</strong> Older transaction waits, younger transaction "dies" (aborts)</p>
            <div class="example-box">
                T1 (timestamp=10) wants lock held by T2 (timestamp=20)<br>
                ‚Üí T1 waits (older, has priority)<br><br>
                T2 (timestamp=20) wants lock held by T1 (timestamp=10)<br>
                ‚Üí T2 dies/aborts (younger, must yield)
            </div>
            <h3>Strategy 2: Wound-Wait</h3>
            <p><strong>Rule:</strong> Older transaction "wounds" (forces abort of) younger, younger waits</p>
        </div>

        <!-- Slide 35 -->
        <div class="slide">
            <h1>Deadlock Prevention</h1>
            <h3>Strategy 3: Ordered Locking (Best!)</h3>
            <p>All transactions acquire locks in same order (e.g., by account_id)</p>
            <pre>-- Rule: Always lock in ascending account_id order

-- Transaction 1
BEGIN TRANSACTION;
UPDATE accounts SET balance = 4500 WHERE account_id = 1; -- Lock 1
UPDATE accounts SET balance = 2500 WHERE account_id = 2; -- Lock 2
COMMIT;

-- Transaction 2 (follows same order)
BEGIN TRANSACTION;
UPDATE accounts SET balance = 5500 WHERE account_id = 1; -- Waits for T1
UPDATE accounts SET balance = 3500 WHERE account_id = 2; -- Then gets this
COMMIT;</pre>
            <div class="highlight success">
                <span class="emoji">‚úÖ</span>No circular wait! T2 waits for T1, but T1 never waits for T2
            </div>
        </div>

        <!-- Slide 36 -->
        <div class="slide">
            <h1>Deadlock Detection</h1>
            <h3>Wait-For Graph Method</h3>
            <p>Build a graph where edge T1 ‚Üí T2 means "T1 waiting for lock held by T2"</p>
            <div class="visual-schedule">
<strong>Scenario:</strong>
T1 holds Alice, wants Bob (held by T2)
T2 holds Bob, wants Charlie (held by T3)
T3 holds Charlie, wants Alice (held by T1)

<strong>Wait-For Graph:</strong>
T1 ‚Üí T2 (T1 waits for T2)
T2 ‚Üí T3 (T2 waits for T3)
T3 ‚Üí T1 (T3 waits for T1)

<strong>Cycle: T1 ‚Üí T2 ‚Üí T3 ‚Üí T1</strong>

<strong>Resolution:</strong> Abort one transaction (e.g., T3) to break cycle
            </div>
        </div>

        <!-- DATABASE RECOVERY SECTION -->

        <!-- Slide 37 -->
        <div class="slide">
            <h1>Database Recovery</h1>
            <h3>Why Do We Need Recovery?</h3>
            <p>Systems fail! Recovery ensures committed transactions survive and uncommitted transactions are undone.</p>
            <div class="analogy-box">
                Auto-save for your database. Finished chapters (committed transactions) are saved, unfinished paragraphs (uncommitted) are discarded.
            </div>
            <h3>Types of Failures:</h3>
            <ul>
                <li><strong>Transaction Failure:</strong> Logic error, constraint violation</li>
                <li><strong>System Crash:</strong> Power failure, OS crash</li>
                <li><strong>Disk Failure:</strong> Hardware dies</li>
            </ul>
        </div>

        <!-- Slide 38 -->
        <div class="slide">
            <h1>Log-Based Recovery</h1>
            <h3>The Transaction Log</h3>
            <p>A <strong>sequential file</strong> that records every change made to the database.</p>
            <div class="visual-schedule">
<strong>Log Record Types:</strong>

[Ti, START]              ‚Üê Transaction Ti started
[Ti, X, old_val, new_val] ‚Üê Ti changed X from old to new
[Ti, COMMIT]             ‚Üê Ti completed successfully
[Ti, ABORT]              ‚Üê Ti was cancelled
[CHECKPOINT]             ‚Üê System checkpoint taken
            </div>
            <div class="highlight info">
                <span class="emoji">üìù</span>The log is the "black box" of the database
            </div>
        </div>

        <!-- Slide 39 -->
        <div class="slide">
            <h1>Example Log Sequence</h1>
            <h3>Bank Transfers with Log</h3>
            <pre>1. [T1, START]
2. [T1, Alice, 5000, 4500]      ‚Üê Alice: $5000 ‚Üí $4500
3. [T1, Bob, 3000, 3500]        ‚Üê Bob: $3000 ‚Üí $3500
4. [T1, COMMIT]                 ‚Üê T1 successful ‚úì

5. [T2, START]
6. [T2, Charlie, 7500, 7000]    ‚Üê Charlie: $7500 ‚Üí $7000
7. -- SYSTEM CRASH! --</pre>
            <h3>After Recovery:</h3>
            <div class="example-box">
                <strong>T1:</strong> Has COMMIT ‚Üí Changes stay (Alice=$4500, Bob=$3500) ‚úì<br>
                <strong>T2:</strong> No COMMIT ‚Üí Changes undone (Charlie=$7500) ‚úì
            </div>
        </div>

        <!-- Slide 40 -->
        <div class="slide">
            <h1>Write-Ahead Logging (WAL)</h1>
            <h3>Critical Rule</h3>
            <div class="highlight error">
                <span class="emoji">üìù</span><strong>Log record MUST be written to disk BEFORE the actual database changes!</strong>
            </div>
            <p><strong>Why?</strong> If we crash after changing data but before writing log, we don't know what happened!</p>
            <div class="example-box">
                <strong>Correct Order:</strong>
                <ol class="step-list">
                    <li>Transaction wants to update Alice's balance</li>
                    <li><strong>FIRST:</strong> Write log [T1, Alice, 5000, 4500] to disk</li>
                    <li><strong>THEN:</strong> Update Alice's balance in database</li>
                    <li>If crash between steps 2-3 ‚Üí Can recover from log!</li>
                </ol>
            </div>
        </div>

        <!-- Slide 41 -->
        <div class="slide">
            <h1>Recovery Operations</h1>
            <h3>Two Key Operations</h3>
            <table>
                <tr>
                    <th>Operation</th>
                    <th>When Used</th>
                    <th>How It Works</th>
                </tr>
                <tr>
                    <td><strong>UNDO</strong></td>
                    <td>Transaction started but didn't commit</td>
                    <td>Read log backwards, restore OLD values</td>
                </tr>
                <tr>
                    <td><strong>REDO</strong></td>
                    <td>Transaction committed but changes might not be on disk</td>
                    <td>Read log forward, apply NEW values</td>
                </tr>
            </table>
        </div>

        <!-- Slide 42 -->
        <div class="slide">
            <h1>UNDO - Rollback Uncommitted</h1>
            <h3>Example</h3>
            <pre>-- Log shows:
[T2, START]
[T2, Alice, 5000, 4500]
-- NO COMMIT! System crashed

-- Recovery performs UNDO:
-- Read log backwards
-- Find [T2, Alice, 5000, 4500]
-- Restore Alice = 5000 (OLD value)

UPDATE accounts SET balance = 5000 WHERE account_id = 1;</pre>
            <div class="highlight info">
                <span class="emoji">‚Ü©Ô∏è</span><strong>UNDO:</strong> Restore old values for uncommitted transactions
            </div>
        </div>

        <!-- Slide 43 -->
        <div class="slide">
            <h1>REDO - Reapply Committed</h1>
            <h3>Example</h3>
            <pre>-- Log shows:
[T1, START]
[T1, Bob, 3000, 3500]
[T1, COMMIT] ‚úì

-- Recovery performs REDO:
-- Read log forward
-- Find [T1, Bob, 3000, 3500] with COMMIT
-- Apply Bob = 3500 (NEW value)

UPDATE accounts SET balance = 3500 WHERE account_id = 2;</pre>
            <div class="highlight success">
                <span class="emoji">‚ôªÔ∏è</span><strong>REDO:</strong> Reapply new values for committed transactions
            </div>
        </div>

        <!-- Slide 44 -->
        <div class="slide">
            <h1>The Checkpoint Problem</h1>
            <h3>Why Checkpoints?</h3>
            <p><strong>Problem:</strong> Transaction logs grow huge! Can't read entire log on every recovery.</p>
            <p><strong>Solution:</strong> Periodically create checkpoints</p>
            <div class="analogy-box">
                Like bookmarks in a book. Instead of reading from page 1, start from your bookmark!
            </div>
        </div>

        <!-- Slide 45 -->
        <div class="slide">
            <h1>Checkpoint Process</h1>
            <h3>How Checkpoints Work</h3>
            <ol class="step-list">
                <li>Stop accepting new transactions (briefly)</li>
                <li>Complete all active transactions</li>
                <li>Flush all changes from memory to disk</li>
                <li>Write [CHECKPOINT] to log</li>
                <li>Resume normal operations</li>
            </ol>
            <div class="highlight success">
                <span class="emoji">üîñ</span><strong>Benefit:</strong> During recovery, only need to read log from last checkpoint!
            </div>
        </div>

        <!-- Slide 46 -->
        <div class="slide">
            <h1>Recovery with Checkpoint</h1>
            <h3>Example</h3>
            <pre>[T1, START]
[T1, Alice, 5000, 4500]
[T1, COMMIT]
[T2, START]
[T2, Bob, 3000, 2500]
[T2, COMMIT]
[CHECKPOINT] ‚Üê Everything before is safely on disk
[T3, START]
[T3, Charlie, 7500, 8000]
[T3, COMMIT]
[T4, START]
[T4, Diana, 2000, 2500]
-- CRASH! --</pre>
            <h3>Recovery:</h3>
            <div class="example-box">
                <strong>Ignore:</strong> T1, T2 (before checkpoint - already on disk)<br>
                <strong>REDO:</strong> T3 (committed after checkpoint)<br>
                <strong>UNDO:</strong> T4 (no commit)
            </div>
        </div>

        <!-- Slide 47 -->
        <div class="slide">
            <h1>Complete Recovery Algorithm</h1>
            <h3>Step-by-Step Process</h3>
            <ol class="step-list">
                <li>Find last <strong>CHECKPOINT</strong> in log</li>
                <li>Scan forward from checkpoint, create two lists:
                    <ul>
                        <li><strong>UNDO list:</strong> Transactions without COMMIT</li>
                        <li><strong>REDO list:</strong> Transactions with COMMIT</li>
                    </ul>
                </li>
                <li><strong>UNDO Phase:</strong> Go backwards, restore old values</li>
                <li><strong>REDO Phase:</strong> Go forward, apply new values</li>
                <li>Database is consistent! ‚úì</li>
            </ol>
        </div>

        <!-- Slide 48 -->
        <div class="slide">
            <h1>Recovery Example Walkthrough</h1>
            <pre>[CHECKPOINT]
[T1, START]
[T1, Alice, 5000, 4000]
[T1, COMMIT]           ‚Üê Goes to REDO list
[T2, START]
[T2, Bob, 3000, 2500]
[T2, Charlie, 7500, 8000]
-- NO COMMIT           ‚Üê Goes to UNDO list
-- CRASH! --</pre>
            <h3>Recovery Process:</h3>
            <div class="visual-schedule">
<strong>Phase 1: UNDO T2 (backwards)</strong>
- Set Charlie = 7500 (old value)
- Set Bob = 3000 (old value)

<strong>Phase 2: REDO T1 (forward)</strong>
- Set Alice = 4000 (new value)

<strong>Final State:</strong>
Alice = $4000 ‚úì, Bob = $3000 ‚úì, Charlie = $7500 ‚úì
            </div>
        </div>

        <!-- Slide 49 -->
        <div class="slide">
            <h1>Summary: Recovery Concepts</h1>
            <table>
                <tr>
                    <th>Concept</th>
                    <th>Purpose</th>
                    <th>Key Point</th>
                </tr>
                <tr>
                    <td><strong>Transaction Log</strong></td>
                    <td>Record all changes</td>
                    <td>Sequential file of all operations</td>
                </tr>
                <tr>
                    <td><strong>Write-Ahead Logging</strong></td>
                    <td>Ensure recoverability</td>
                    <td>Log BEFORE database change</td>
                </tr>
                <tr>
                    <td><strong>UNDO</strong></td>
                    <td>Rollback uncommitted</td>
                    <td>Restore old values</td>
                </tr>
                <tr>
                    <td><strong>REDO</strong></td>
                    <td>Reapply committed</td>
                    <td>Apply new values</td>
                </tr>
                <tr>
                    <td><strong>Checkpoint</strong></td>
                    <td>Limit log scanning</td>
                    <td>Start recovery here</td>
                </tr>
            </table>
        </div>

        <!-- Slide 50 -->
        <div class="slide">
            <h1>Putting It All Together</h1>
            <h3>Complete Transaction Lifecycle</h3>
            <ol class="step-list">
                <li><strong>BEGIN TRANSACTION</strong> - Write [T1, START] to log</li>
                <li><strong>Execute Operations</strong> - For each change, write log entry first (WAL)</li>
                <li><strong>Acquire Locks</strong> - Follow 2PL protocol for concurrency</li>
                <li><strong>Check Serializability</strong> - Precedence graph has no cycles</li>
                <li><strong>COMMIT</strong> - Write [T1, COMMIT], release locks</li>
                <li><strong>If Crash</strong> - Use log to UNDO uncommitted, REDO committed</li>
            </ol>
        </div>

        <!-- Slide 51 -->
        <div class="slide">
            <h1>Real-World Example</h1>
            <h3>Complete Safe Transfer</h3>
            <pre>-- 1. Start transaction (log: [T1, START])
BEGIN TRANSACTION;

-- 2. Read and verify (acquires shared locks)
SELECT balance FROM accounts WHERE account_id = 1; -- $5000

-- 3. Deduct (log first, then update)
-- Log: [T1, Alice, 5000, 4000]
UPDATE accounts SET balance = 4000 WHERE account_id = 1;

-- 4. Add (log first, then update)
-- Log: [T1, Bob, 3000, 4000]
UPDATE accounts SET balance = 4000 WHERE account_id = 2;

-- 5. Commit (log: [T1, COMMIT], release locks)
COMMIT;

-- All ACID properties enforced:
-- ‚úì Atomicity: Both or neither
-- ‚úì Consistency: Total = $17,500 before and after
-- ‚úì Isolation: Locks prevent interference
-- ‚úì Durability: Log ensures survival of crash</pre>
        </div>

        <!-- Slide 52 -->
        <div class="slide">
            <h1>Key Takeaways</h1>
            <h3>What You Need to Remember</h3>
            <div class="highlight success">
                <span class="emoji">üìÖ</span><strong>Schedules:</strong> Order matters! Serial is safe, concurrent needs control
            </div>
            <div class="highlight info">
                <span class="emoji">üîÑ</span><strong>Serializability:</strong> Use precedence graphs - no cycles = good!
            </div>
            <div class="highlight">
                <span class="emoji">üîí</span><strong>Locking:</strong> 2PL guarantees serializability, watch for deadlocks
            </div>
            <div class="highlight error">
                <span class="emoji">üíæ</span><strong>Recovery:</strong> Log everything, checkpoint periodically, UNDO/REDO after crash
            </div>
        </div>

        <!-- Slide 53 -->
        <div class="slide">
            <h1>Practice Questions</h1>
            <h3>Test Your Understanding</h3>
            <div class="example-box">
                <strong>Q1:</strong> If precedence graph has a cycle, is the schedule serializable?<br>
                <strong>A:</strong> No - cycle means NOT conflict serializable
            </div>
            <div class="example-box">
                <strong>Q2:</strong> What's the difference between UNDO and REDO?<br>
                <strong>A:</strong> UNDO restores old values (uncommitted), REDO applies new values (committed)
            </div>
            <div class="example-box">
                <strong>Q3:</strong> Why do we need Write-Ahead Logging?<br>
                <strong>A:</strong> To ensure log is written before data changes, enabling recovery
            </div>
        </div>

        <!-- Slide 54 -->
        <div class="slide">
            <h1>Course Complete! üéì</h1>
            <h2>You've Mastered:</h2>
            <ul>
                <li>‚úÖ ACID Properties</li>
                <li>‚úÖ Transaction Schedules</li>
                <li>‚úÖ Serializability Testing</li>
                <li>‚úÖ Concurrency Control (Locking, 2PL)</li>
                <li>‚úÖ Deadlock Handling</li>
                <li>‚úÖ Database Recovery</li>
                <li>‚úÖ Log-Based Recovery</li>
                <li>‚úÖ Checkpoints</li>
            </ul>
            <div class="highlight success" style="margin-top: 30px; font-size: 1.2em;">
                <span class="emoji">üåü</span>You're now ready to design and manage robust database systems!
            </div>
        </div>

        <div class="controls">
            <button id="prevBtn" onclick="changeSlide(-1)">‚Üê Previous</button>
            <span class="slide-counter">
                <span id="currentSlide">1</span> / <span id="totalSlides">54</span>
            </span>
            <button id="nextBtn" onclick="changeSlide(1)">Next ‚Üí</button>
        </div>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        
        document.getElementById('totalSlides').textContent = totalSlides;

        function showSlide(n) {
            slides[currentSlide].classList.remove('active');
            currentSlide = (n + totalSlides) % totalSlides;
            slides[currentSlide].classList.add('active');
            
            document.getElementById('currentSlide').textContent = currentSlide + 1;
            
            document.getElementById('prevBtn').disabled = currentSlide === 0;
            document.getElementById('nextBtn').disabled = currentSlide === totalSlides - 1;
        }

        function changeSlide(direction) {
            showSlide(currentSlide + direction);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' && currentSlide > 0) {
                changeSlide(-1);
            } else if (e.key === 'ArrowRight' && currentSlide < totalSlides - 1) {
                changeSlide(1);
            }
        });

        showSlide(0);
    </script>
</body>
</html>
